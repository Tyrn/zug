/*
 ******************************************************************************
 * @file           : circus.c
 * @brief          : A circular buffer servicing the VCP
 ******************************************************************************
 */
#include "usbd_cdc_if.h"
#include "circus.h"

#ifndef NO_MIN
  struct min_context min_ctx;
#endif

/* USB Device Core handle declaration.   (usb_device.c) */
extern USBD_HandleTypeDef hUsbDeviceFS;

/** Received data over USB are stored in this buffer   (usbd_cdc_if.c) */
extern uint8_t UserRxBufferFS[];

/** Data to send over USB CDC are stored in this buffer   (usbd_cdc_if.c) */
extern uint8_t UserTxBufferFS[];

#define circusRX_BUFFER_MAX_WRITE_INDEX (APP_RX_DATA_SIZE - CDC_DATA_FS_MAX_PACKET_SIZE)

typedef struct circusVCP_FIFO_TYPE
{
  uint8_t *data;  // Will point to the Cube-generated Tx or Rx buffer
  int wr;    // Write index
  int rd;    // Read index
  int lb;    // Additional index
} circusVCP_FIFO;

// Circular FIFO to store outgoing data until it can be sent over USB
static circusVCP_FIFO vcp_tx_fifo;
// Circular FIFO to store incoming data from the host over USB
static circusVCP_FIFO vcp_rx_fifo;

/*
 * @brief  To be called from CDC_Init_FS() (usbd_cdc_if.c)
 * @retval USBD_OK
 */
int8_t c_circus_cdc_init_fs()
{
  // Circular FIFO initializations :
  vcp_tx_fifo.data = UserTxBufferFS;  // Use the buffer generated by Cube
  vcp_tx_fifo.wr = 0;
  vcp_tx_fifo.rd = 0;
  vcp_tx_fifo.lb = 0;
  vcp_rx_fifo.data = UserRxBufferFS;  // Use the buffer generated by Cube
  vcp_rx_fifo.wr = 0;
  vcp_rx_fifo.rd = 0;
  vcp_rx_fifo.lb = 0;

  /* Set Application Buffers */
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
  return (USBD_OK);
}

/*
 * @brief  To be called from CDC_Receive_FS() (usbd_cdc_if.c)
 * @param  Buf: Buffer of data to be received
 * @param  Len: Number of data received (in bytes)
 * @retval USBD_OK
 */
int8_t c_circus_cdc_receive_fs(uint8_t *Buf, uint32_t *Len)
{
  // Update the write index for the next incoming packet
  vcp_rx_fifo.wr += *Len;
  // Is the new value too close to the end of the FIFO ?
  if (vcp_rx_fifo.wr >= circusRX_BUFFER_MAX_WRITE_INDEX)
  {
    // Solution : wrap-around (and save wr as lb)
    vcp_rx_fifo.lb = vcp_rx_fifo.wr;
    vcp_rx_fifo.wr = 0;
  }
  // Tell the driver where to write the next incoming packet
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, vcp_rx_fifo.data + vcp_rx_fifo.wr);
  // Receive the next packet
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
  return (USBD_OK);
}

/*
 * @brief  Calculate the available space in the Tx FIFO
 * @retval Available space in bytes
 */
int l_circus_vcp_send_available(void)
{
  int cap = vcp_tx_fifo.wr - vcp_tx_fifo.rd;   // occupied space in the Tx FIFO
  if (cap < 0)    // FIFO contents wrap around
    cap += APP_TX_DATA_SIZE;
  cap = APP_TX_DATA_SIZE - cap;      // available capacity
  return cap;
}

/*
 * @brief  Put array of bytes into the circular buffer
 * @param  buf: Data to be sent
 * @param  len: Bytes to be sent
 * @retval 0 - success; -1 - not enough space
 */
int l_circus_vcp_send(uint8_t *buf, uint16_t len)
{
  int cap = l_circus_vcp_send_available();  // available capacity
  // Step 2 : compare with argument
  if (cap < len)
    return -1;   // Not enough room to copy "buf" into the FIFO => error
  // Step 3 : does buf fit in the tail ?
  int tail = APP_TX_DATA_SIZE - vcp_tx_fifo.wr;
  if (tail >= len)
  {
    // Copy buf into the tail of the FIFO
    memcpy(&vcp_tx_fifo.data[vcp_tx_fifo.wr], buf, len);
    // Update "wr" index
    vcp_tx_fifo.wr += len;
    // In case "len" == "tail", next write goes to the head
    if (vcp_tx_fifo.wr == APP_TX_DATA_SIZE)
      vcp_tx_fifo.wr = 0;
  }
  else
  {
    // Copy the head of "buf" to the tail of the FIFO
    memcpy(&vcp_tx_fifo.data[vcp_tx_fifo.wr], buf, tail);
    // Copy the tail of "buf" to the head of the FIFO :
    memcpy(vcp_tx_fifo.data, &buf[tail], len - tail);
    // Update the "wr" index
    vcp_tx_fifo.wr = len - tail;
  }
  return 0;  // successful completion
}

/*
 * @brief  Calculate the available space in the Rx FIFO
 * @retval Available space in bytes
 */
int l_circus_vcp_recv_available(void)
{
  int cap = vcp_rx_fifo.wr - vcp_rx_fifo.rd;
  if (cap == 0)
    return 0;
  if (cap < 0)  // FIFO contents wrap around
    cap += vcp_rx_fifo.lb;  // Notice the use of lb
  return cap;
}

/*
 * @brief  Scoop up to len bytes from the circular buffer
 * @param  buf: Buffer of at least len size
 * @param  len: Upper reception limit
 * @retval Number of bytes received
 */
int l_circus_vcp_recv(uint8_t *buf, uint16_t len)
{
  // Compute how much data is in the FIFO
  int cap = l_circus_vcp_recv_available();
  if (cap == 0)
    return 0;      // Empty FIFO, no data to read
  // Limit the FIFO read to the available data
  if (len > cap)
    len = cap;
  // Save len : it'll be the return value
  int retval = len;
  // Read the data
  while (len)
  {
    len--;
    *buf = vcp_rx_fifo.data[vcp_rx_fifo.rd];
    buf++;
    vcp_rx_fifo.rd++;    // Update read index
    if (vcp_rx_fifo.rd == vcp_rx_fifo.lb)  // Check for wrap-around
      vcp_rx_fifo.rd = 0;      // Follow wrap-around
  }
  return retval;
}

/*
 * @brief Send to VCP bytes, dispatched by ...vcp_send();
 *        to be called on schedule (SysTick or whatever is suitable)
 */
void v_circus_vcp_service()
{
  USBD_CDC_HandleTypeDef *hcdc =
      (USBD_CDC_HandleTypeDef*) hUsbDeviceFS.pClassData;
  // Test if the USB CDC is ready to transmit
  if (hcdc->TxState == 0)
  {
    // Update the FIFO to reflect the completion of the last transmission
    vcp_tx_fifo.rd = vcp_tx_fifo.lb;
    // Compute how much data is in the FIFO
    int cap = vcp_tx_fifo.wr - vcp_tx_fifo.rd;
    if (cap != 0)  // The FIFO is empty : return immediately
    {
      if (cap < 0)  // The FIFO contents wrap-around
      {
        // Send only the tail of the FIFO
        USBD_CDC_SetTxBuffer(&hUsbDeviceFS, &vcp_tx_fifo.data[vcp_tx_fifo.rd],
        APP_TX_DATA_SIZE - vcp_tx_fifo.rd);
        USBD_CDC_TransmitPacket(&hUsbDeviceFS);
        vcp_tx_fifo.lb = 0;    // Lock the tailâ€™s data
      }
      else  // No wrap-around : send the whole FIFO
      {
        USBD_CDC_SetTxBuffer(&hUsbDeviceFS, &vcp_tx_fifo.data[vcp_tx_fifo.rd],
            cap);
        USBD_CDC_TransmitPacket(&hUsbDeviceFS);
        vcp_tx_fifo.lb = vcp_tx_fifo.wr; // lock the data
      }
    }
  }
}
